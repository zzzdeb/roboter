// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
#ifndef XPCC_STM32_GPIO_HPP
#define XPCC_STM32_GPIO_HPP

#include "../../../device.hpp"
#include "../../../type_ids.hpp"
#include <xpcc/architecture/interface/gpio.hpp>
#include <xpcc/architecture/interface/i2c.hpp>
#include <xpcc/math/utils/bit_operation.hpp>

#include "../../adc/stm32/adc_1.hpp"
#include "../../adc/stm32/adc_2.hpp"
#include "../../adc/stm32/adc_3.hpp"
extern void xpcc_gpio_enable(void);

/**
 * @ingroup 	platform
 * @defgroup	stm32f407vg
 */

/**
 * @ingroup 	stm32f407vg
 * @defgroup	stm32f407vg_gpio GPIO
 */

namespace xpcc
{

namespace stm32
{

/// @ingroup stm32f407vg_gpio
struct Gpio
{
	enum class
	InputType
	{
		Floating = 0x0,	///< floating on input
		PullUp = 0x1,	///< pull-up on input
		PullDown = 0x2,	///< pull-down on input
	};

	enum class
	OutputType
	{
		PushPull = 0x0,		///< push-pull on output
		OpenDrain = 0x1,	///< open-drain on output
	};

	enum class
	OutputSpeed
	{
		MHz2 = 0,		///< Low speed
		MHz25 = 0x1,	///< Medium speed
		MHz50 = 0x2,	///< Fast speed
		MHz100 = 0x3,	///< High speed on 30 pF (80 MHz Output max speed on 15 pF)
	};

	enum class
	InputTrigger
	{
		RisingEdge,
		FallingEdge,
		BothEdges,
	};

	/// The Port a Gpio Pin is connected to.
	enum class
	Port
	{
		A = 0,
		C = 2,
		B = 1,
		E = 4,
		D = 3,
		H = 7,
	};

	static void
	enable()
	{
		xpcc_gpio_enable();
	}

	static void
	disable()
	{
		// FIXME: Implement
	}

protected:
	/// I/O Direction Mode values for this specific pin.
	enum class
	Mode
	{
		Input  = 0x0,
		Output = 0x1,
		AlternateFunction = 0x2,
		Analog = 0x3,
		Mask   = 0x3,
	};

	// 0..7 = AFRL[31:0]
	// 8..15 = AFRH[31:0]
	enum class
	AlternateFunction
	{
		AF_0 = 0x00,		///< System
		AF_1 = 0x01,		///< TIM1/2
		AF_2 = 0x02,		///< TIM3..5
		AF_3 = 0x03,		///< TIM8...11
		AF_4 = 0x04,		///< I2C1..3
		AF_5 = 0x05,		///< SPI1/2
		AF_6 = 0x06,		///< SPI3
		AF_7 = 0x07,		///< USART1..3
		AF_8 = 0x08,		///< USART4..6
		AF_9 = 0x09,		///< CAN1/2, TIM12..14
		AF_10 = 0x0a,		///< OTG_FS, OTG_HS
		AF_11 = 0x0b,		///< ETH
		AF_12 = 0x0c,		///< FSMC, SDIO, OTG_HS (configured as FS)
		AF_13 = 0x0d,		///< DCMI
		AF_14 = 0x0e,		///< Reserved
		AF_15 = 0x0f,		///< EVENTOUT
	};

	/// @cond
	// Enum Class To Integer helper functions.
	static constexpr uint32_t
	i(InputType pull) { return uint32_t(pull); }
	static constexpr uint32_t
	i(OutputType out) { return uint32_t(out); }
	static constexpr uint32_t
	i(OutputSpeed speed) { return uint32_t(speed); }
	static constexpr uint32_t
	i(Mode mode) { return uint32_t(mode); }
	static constexpr uint32_t
	i(AlternateFunction af) { return uint32_t(af); }
	/// @endcond
};

// Gpio Classes created from the XML Device File Gpio Description
/// Output class for Pin A0
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA0 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA0 connects to Channel0 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel0;
	/// GpioOutputA0 connects to Channel0 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel0;
	/// GpioOutputA0 connects to Channel0 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel0;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA0 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputA0 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A0
/// @ingroup	stm32f407vg_gpio
struct GpioInputA0 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA0 connects to Channel0 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel0;
	/// GpioInputA0 connects to Channel0 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel0;
	/// GpioInputA0 connects to Channel0 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel0;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA0 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA0 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA0 as ExternalTrigger to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA0 as ExternalTrigger to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA0 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA0 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA0 as Channel0 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel0 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA0 as Channel0 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel0 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA0 as Channel0 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel0 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A0
/// @ingroup	stm32f407vg_gpio
struct GpioA0 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA0 connects to Channel0 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel0;
	/// GpioA0 connects to Channel0 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel0;
	/// GpioA0 connects to Channel0 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel0;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA0 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA0 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA0 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA0 as Channel1 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA0 as ExternalTrigger to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA0 as ExternalTrigger to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA0 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA0 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA0 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioA0 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioA0 as Channel0 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel0 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA0 as Channel0 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel0 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA0 as Channel0 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel0 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA0 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A1
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA1 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA1 connects to Channel1 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel1;
	/// GpioOutputA1 connects to Channel1 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel1;
	/// GpioOutputA1 connects to Channel1 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel1;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA1 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA1 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A1
/// @ingroup	stm32f407vg_gpio
struct GpioInputA1 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA1 connects to Channel1 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel1;
	/// GpioInputA1 connects to Channel1 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel1;
	/// GpioInputA1 connects to Channel1 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel1;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA1 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputA1 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputA1 as Channel1 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel1 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA1 as Channel1 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel1 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA1 as Channel1 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel1 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A1
/// @ingroup	stm32f407vg_gpio
struct GpioA1 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA1 connects to Channel1 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel1;
	/// GpioA1 connects to Channel1 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel1;
	/// GpioA1 connects to Channel1 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel1;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA1 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA1 as Channel2 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA1 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA1 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA1 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioA1 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioA1 as Channel1 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel1 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA1 as Channel1 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel1 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA1 as Channel1 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel1 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA1 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A2
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA2 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA2 connects to Channel2 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel2;
	/// GpioOutputA2 connects to Channel2 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel2;
	/// GpioOutputA2 connects to Channel2 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel2;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA2 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA2 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA2 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA2 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A2
/// @ingroup	stm32f407vg_gpio
struct GpioInputA2 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA2 connects to Channel2 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel2;
	/// GpioInputA2 connects to Channel2 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel2;
	/// GpioInputA2 connects to Channel2 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel2;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA2 as Channel2 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel2 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA2 as Channel2 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel2 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA2 as Channel2 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel2 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A2
/// @ingroup	stm32f407vg_gpio
struct GpioA2 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA2 connects to Channel2 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel2;
	/// GpioA2 connects to Channel2 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel2;
	/// GpioA2 connects to Channel2 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel2;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA2 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA2 as Channel3 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA2 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA2 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA2 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA2 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA2 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA2 as Channel2 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel2 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA2 as Channel2 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel2 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA2 as Channel2 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel2 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA2 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A3
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA3 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA3 connects to Channel3 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel3;
	/// GpioOutputA3 connects to Channel3 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel3;
	/// GpioOutputA3 connects to Channel3 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel3;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A3
/// @ingroup	stm32f407vg_gpio
struct GpioInputA3 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA3 connects to Channel3 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel3;
	/// GpioInputA3 connects to Channel3 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel3;
	/// GpioInputA3 connects to Channel3 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel3;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA3 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA3 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA3 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA3 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA3 as Channel3 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel3 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA3 as Channel3 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel3 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA3 as Channel3 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel3 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A3
/// @ingroup	stm32f407vg_gpio
struct GpioA3 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA3 connects to Channel3 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel3;
	/// GpioA3 connects to Channel3 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel3;
	/// GpioA3 connects to Channel3 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel3;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA3 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA3 as Channel4 to Timer5.
	xpcc_always_inline static void
	connect(TypeId::Timer5Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA3 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA3 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA3 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA3 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA3 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA3 as Channel3 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel3 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA3 as Channel3 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel3 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA3 as Channel3 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel3 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA3 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A4
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA4 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA4 connects to Channel4 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel4;
	/// GpioOutputA4 connects to Channel4 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel4;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputA4 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA4 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA4 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA4 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A4
/// @ingroup	stm32f407vg_gpio
struct GpioInputA4 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA4 connects to Channel4 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel4;
	/// GpioInputA4 connects to Channel4 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel4;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioInputA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioInputA4 as Channel4 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel4 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA4 as Channel4 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel4 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A4
/// @ingroup	stm32f407vg_gpio
struct GpioA4 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA4 connects to Channel4 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel4;
	/// GpioA4 connects to Channel4 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel4;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA4 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioA4 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioA4 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA4 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA4 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA4 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA4 as Channel4 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel4 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA4 as Channel4 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel4 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA4 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A5
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA5 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA5 connects to Channel5 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel5;
	/// GpioOutputA5 connects to Channel5 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel5;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA5 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA5 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A5
/// @ingroup	stm32f407vg_gpio
struct GpioInputA5 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA5 connects to Channel5 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel5;
	/// GpioInputA5 connects to Channel5 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel5;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA5 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA5 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA5 as Channel5 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel5 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA5 as Channel5 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel5 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A5
/// @ingroup	stm32f407vg_gpio
struct GpioA5 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA5 connects to Channel5 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel5;
	/// GpioA5 connects to Channel5 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel5;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA5 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA5 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA5 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA5 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA5 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA5 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA5 as Channel5 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel5 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA5 as Channel5 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel5 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA5 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A6
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA6 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA6 connects to Channel6 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel6;
	/// GpioOutputA6 connects to Channel6 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel6;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A6
/// @ingroup	stm32f407vg_gpio
struct GpioInputA6 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA6 connects to Channel6 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel6;
	/// GpioInputA6 connects to Channel6 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel6;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA6 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA6 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA6 as BreakIn to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA6 as BreakIn to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA6 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputA6 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputA6 as Channel6 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel6 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA6 as Channel6 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel6 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A6
/// @ingroup	stm32f407vg_gpio
struct GpioA6 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA6 connects to Channel6 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel6;
	/// GpioA6 connects to Channel6 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel6;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA6 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA6 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA6 as BreakIn to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA6 as BreakIn to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA6 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA6 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA6 as Channel1 to Timer13.
	xpcc_always_inline static void
	connect(TypeId::Timer13Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA6 as Channel6 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel6 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA6 as Channel6 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel6 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA6 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A7
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA7 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputA7 connects to Channel7 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel7;
	/// GpioOutputA7 connects to Channel7 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel7;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputA7 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA7 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A7
/// @ingroup	stm32f407vg_gpio
struct GpioInputA7 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputA7 connects to Channel7 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel7;
	/// GpioInputA7 connects to Channel7 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel7;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputA7 as Channel7 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel7 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputA7 as Channel7 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel7 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A7
/// @ingroup	stm32f407vg_gpio
struct GpioA7 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioA7 connects to Channel7 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel7;
	/// GpioA7 connects to Channel7 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel7;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA7 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA7 as Channel1N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioA7 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA7 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA7 as Channel1 to Timer14.
	xpcc_always_inline static void
	connect(TypeId::Timer14Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA7 as Channel7 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel7 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioA7 as Channel7 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel7 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA7 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A8
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA8 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA8 as  to ClockOutput1.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioOutputA8 as  to ClockOutput1.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioOutputA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA8 as Ck to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA8 as Ck to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA8 as Sck to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA8 as Sck to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A8
/// @ingroup	stm32f407vg_gpio
struct GpioInputA8 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A8
/// @ingroup	stm32f407vg_gpio
struct GpioA8 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA8 as  to ClockOutput1.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioA8 as  to ClockOutput1.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA8 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA8 as Scl to I2cMaster3.
	inline static void
	connect(TypeId::I2cMaster3Scl /* t */, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA8 >();
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioA8 as Ck to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA8 as Ck to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA8 as Sck to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA8 as Sck to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA8 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A9
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA9 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA9 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA9 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA9 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA9 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A9
/// @ingroup	stm32f407vg_gpio
struct GpioInputA9 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A9
/// @ingroup	stm32f407vg_gpio
struct GpioA9 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA9 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA9 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA9 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA9 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA9 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA9 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A10
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA10 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A10
/// @ingroup	stm32f407vg_gpio
struct GpioInputA10 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA10 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA10 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA10 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA10 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A10
/// @ingroup	stm32f407vg_gpio
struct GpioA10 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA10 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA10 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA10 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA10 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA10 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA10 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A11
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA11 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */) {
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioOutputA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A11
/// @ingroup	stm32f407vg_gpio
struct GpioInputA11 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA11 as Cts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA11 as Cts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputA11 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputA11 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */) {
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioInputA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A11
/// @ingroup	stm32f407vg_gpio
struct GpioA11 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA11 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA11 as Cts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA11 as Cts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA11 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA11 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */) {
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioA11 as Dm to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDm /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA11 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A12
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA12 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA12 as Rts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA12 as Rts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputA12 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputA12 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */) {
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioOutputA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A12
/// @ingroup	stm32f407vg_gpio
struct GpioInputA12 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA12 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA12 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */) {
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioInputA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A12
/// @ingroup	stm32f407vg_gpio
struct GpioA12 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA12 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA12 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA12 as Rts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA12 as Rts to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioA12 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA12 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */) {
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	/// Connect GpioA12 as Dp to Usb.
	xpcc_always_inline static void
	connect(TypeId::UsbDp /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_10);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA12 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A13
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA13 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A13
/// @ingroup	stm32f407vg_gpio
struct GpioInputA13 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A13
/// @ingroup	stm32f407vg_gpio
struct GpioA13 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA13 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A14
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA14 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A14
/// @ingroup	stm32f407vg_gpio
struct GpioInputA14 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A14
/// @ingroup	stm32f407vg_gpio
struct GpioA14 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA14 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin A15
/// @ingroup	stm32f407vg_gpio
struct GpioOutputA15 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOA->MODER &= ~mask2;
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
		GPIOA->PUPDR &= ~mask2;
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin A15
/// @ingroup	stm32f407vg_gpio
struct GpioInputA15 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA15 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA15 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioInputA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin A15
/// @ingroup	stm32f407vg_gpio
struct GpioA15 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::A;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOA->MODER = (GPIOA->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOA->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOA->OTYPER  = (GPIOA->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOA->PUPDR   = (GPIOA->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER   = (GPIOA->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOA->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOA->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOA->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOA->MODER   &= ~mask2;
		// reset output type and speed
		GPIOA->OTYPER  &= ~mask;
		GPIOA->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOA->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOA->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOA->AFR[af_id] = (GPIOA->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA15 as Channel1 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA15 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA15 as ExternalTrigger to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA15 as Nss to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioA15 as Nss to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioA15 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B0
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB0 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputB0 connects to Channel8 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel8;
	/// GpioOutputB0 connects to Channel8 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel8;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B0
/// @ingroup	stm32f407vg_gpio
struct GpioInputB0 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputB0 connects to Channel8 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel8;
	/// GpioInputB0 connects to Channel8 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel8;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB0 as Channel8 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel8 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputB0 as Channel8 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel8 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B0
/// @ingroup	stm32f407vg_gpio
struct GpioB0 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioB0 connects to Channel8 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel8;
	/// GpioB0 connects to Channel8 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel8;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB0 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB0 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB0 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB0 as Channel8 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel8 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioB0 as Channel8 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel8 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB0 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B1
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB1 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputB1 connects to Channel9 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel9;
	/// GpioOutputB1 connects to Channel9 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel9;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B1
/// @ingroup	stm32f407vg_gpio
struct GpioInputB1 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputB1 connects to Channel9 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel9;
	/// GpioInputB1 connects to Channel9 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel9;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB1 as Channel9 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel9 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputB1 as Channel9 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel9 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B1
/// @ingroup	stm32f407vg_gpio
struct GpioB1 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioB1 connects to Channel9 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel9;
	/// GpioB1 connects to Channel9 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel9;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB1 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB1 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB1 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB1 as Channel9 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel9 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioB1 as Channel9 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel9 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB1 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B2
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB2 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B2
/// @ingroup	stm32f407vg_gpio
struct GpioInputB2 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B2
/// @ingroup	stm32f407vg_gpio
struct GpioB2 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB2 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B3
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB3 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB3 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB3 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB3 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputB3 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B3
/// @ingroup	stm32f407vg_gpio
struct GpioInputB3 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B3
/// @ingroup	stm32f407vg_gpio
struct GpioB3 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB3 as Channel2 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB3 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB3 as Sck to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB3 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioB3 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB3 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B4
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB4 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B4
/// @ingroup	stm32f407vg_gpio
struct GpioInputB4 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB4 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB4 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB4 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioInputB4 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B4
/// @ingroup	stm32f407vg_gpio
struct GpioB4 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB4 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB4 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB4 as Miso to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB4 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioB4 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB4 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B5
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB5 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB5 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB5 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB5 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputB5 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B5
/// @ingroup	stm32f407vg_gpio
struct GpioInputB5 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB5 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputB5 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B5
/// @ingroup	stm32f407vg_gpio
struct GpioB5 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB5 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB5 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB5 as Mosi to SpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB5 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioB5 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioB5 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB5 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB5 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B6
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB6 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB6 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB6 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB6 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB6 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB6 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputB6 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B6
/// @ingroup	stm32f407vg_gpio
struct GpioInputB6 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B6
/// @ingroup	stm32f407vg_gpio
struct GpioB6 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB6 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB6 as Scl to I2cMaster1.
	inline static void
	connect(TypeId::I2cMaster1Scl /* t */, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB6 >();
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioB6 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB6 as Tx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB6 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB6 as Mosi to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB6 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB6 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB6 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B7
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB7 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B7
/// @ingroup	stm32f407vg_gpio
struct GpioInputB7 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB7 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB7 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB7 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB7 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B7
/// @ingroup	stm32f407vg_gpio
struct GpioB7 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB7 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB7 as Sda to I2cMaster1.
	inline static void
	connect(TypeId::I2cMaster1Sda /* t */, InputType type=InputType::Floating) {
		configure(type);
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioB7 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB7 as Rx to Uart1.
	xpcc_always_inline static void
	connect(TypeId::Uart1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB7 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB7 as Miso to UartSpiMaster1.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster1Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioB7 as Nl to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNl /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB7 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B8
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB8 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B8
/// @ingroup	stm32f407vg_gpio
struct GpioInputB8 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB8 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputB8 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B8
/// @ingroup	stm32f407vg_gpio
struct GpioB8 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB8 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB8 as Channel1 to Timer10.
	xpcc_always_inline static void
	connect(TypeId::Timer10Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB8 as Scl to I2cMaster1.
	inline static void
	connect(TypeId::I2cMaster1Scl /* t */, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB8 >();
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioB8 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB8 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB8 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B9
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB9 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB9 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputB9 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B9
/// @ingroup	stm32f407vg_gpio
struct GpioInputB9 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B9
/// @ingroup	stm32f407vg_gpio
struct GpioB9 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB9 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB9 as Channel1 to Timer11.
	xpcc_always_inline static void
	connect(TypeId::Timer11Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB9 as Sda to I2cMaster1.
	inline static void
	connect(TypeId::I2cMaster1Sda /* t */, InputType type=InputType::Floating) {
		configure(type);
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB9 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB9 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB9 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB9 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B10
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB10 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB10 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB10 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B10
/// @ingroup	stm32f407vg_gpio
struct GpioInputB10 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B10
/// @ingroup	stm32f407vg_gpio
struct GpioB10 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB10 as Channel3 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB10 as Scl to I2cMaster2.
	inline static void
	connect(TypeId::I2cMaster2Scl /* t */, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB10 >();
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioB10 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB10 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB10 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B11
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB11 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B11
/// @ingroup	stm32f407vg_gpio
struct GpioInputB11 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B11
/// @ingroup	stm32f407vg_gpio
struct GpioB11 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB11 as Channel4 to Timer2.
	xpcc_always_inline static void
	connect(TypeId::Timer2Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB11 as Sda to I2cMaster2.
	inline static void
	connect(TypeId::I2cMaster2Sda /* t */, InputType type=InputType::Floating) {
		configure(type);
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	/// Connect GpioB11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB11 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B12
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB12 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B12
/// @ingroup	stm32f407vg_gpio
struct GpioInputB12 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB12 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB12 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB12 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputB12 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B12
/// @ingroup	stm32f407vg_gpio
struct GpioB12 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB12 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB12 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB12 as Nss to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Nss /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB12 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB12 as Rx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB12 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B13
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB13 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB13 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB13 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB13 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputB13 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B13
/// @ingroup	stm32f407vg_gpio
struct GpioInputB13 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB13 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputB13 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B13
/// @ingroup	stm32f407vg_gpio
struct GpioB13 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB13 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB13 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB13 as Sck to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB13 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB13 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB13 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB13 as Tx to Can2.
	xpcc_always_inline static void
	connect(TypeId::Can2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB13 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B14
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB14 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB14 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB14 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B14
/// @ingroup	stm32f407vg_gpio
struct GpioInputB14 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB14 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB14 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B14
/// @ingroup	stm32f407vg_gpio
struct GpioB14 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB14 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB14 as Channel2N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB14 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB14 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB14 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB14 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB14 as Channel1 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB14 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin B15
/// @ingroup	stm32f407vg_gpio
struct GpioOutputB15 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOB->MODER &= ~mask2;
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
		GPIOB->PUPDR &= ~mask2;
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputB15 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB15 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin B15
/// @ingroup	stm32f407vg_gpio
struct GpioInputB15 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin B15
/// @ingroup	stm32f407vg_gpio
struct GpioB15 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::B;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOB->MODER = (GPIOB->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOB->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOB->OTYPER  = (GPIOB->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOB->OSPEEDR = (GPIOB->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOB->PUPDR   = (GPIOB->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER   = (GPIOB->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOB->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOB->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOB->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOB->MODER   &= ~mask2;
		// reset output type and speed
		GPIOB->OTYPER  &= ~mask;
		GPIOB->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOB->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOB->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOB->AFR[af_id] = (GPIOB->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB15 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB15 as Channel3N to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioB15 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB15 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioB15 as Channel2 to Timer12.
	xpcc_always_inline static void
	connect(TypeId::Timer12Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioB15 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C0
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC0 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputC0 connects to Channel10 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel10;
	/// GpioOutputC0 connects to Channel10 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel10;
	/// GpioOutputC0 connects to Channel10 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel10;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C0
/// @ingroup	stm32f407vg_gpio
struct GpioInputC0 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputC0 connects to Channel10 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel10;
	/// GpioInputC0 connects to Channel10 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel10;
	/// GpioInputC0 connects to Channel10 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel10;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC0 as Channel10 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel10 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC0 as Channel10 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel10 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC0 as Channel10 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel10 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C0
/// @ingroup	stm32f407vg_gpio
struct GpioC0 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioC0 connects to Channel10 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel10;
	/// GpioC0 connects to Channel10 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel10;
	/// GpioC0 connects to Channel10 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel10;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC0 as Channel10 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel10 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC0 as Channel10 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel10 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC0 as Channel10 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel10 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC0 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C1
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC1 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputC1 connects to Channel11 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel11;
	/// GpioOutputC1 connects to Channel11 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel11;
	/// GpioOutputC1 connects to Channel11 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel11;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C1
/// @ingroup	stm32f407vg_gpio
struct GpioInputC1 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputC1 connects to Channel11 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel11;
	/// GpioInputC1 connects to Channel11 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel11;
	/// GpioInputC1 connects to Channel11 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel11;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC1 as Channel11 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel11 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC1 as Channel11 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel11 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC1 as Channel11 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel11 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C1
/// @ingroup	stm32f407vg_gpio
struct GpioC1 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioC1 connects to Channel11 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel11;
	/// GpioC1 connects to Channel11 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel11;
	/// GpioC1 connects to Channel11 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel11;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC1 as Channel11 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel11 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC1 as Channel11 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel11 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC1 as Channel11 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel11 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC1 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C2
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC2 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputC2 connects to Channel12 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel12;
	/// GpioOutputC2 connects to Channel12 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel12;
	/// GpioOutputC2 connects to Channel12 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel12;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C2
/// @ingroup	stm32f407vg_gpio
struct GpioInputC2 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputC2 connects to Channel12 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel12;
	/// GpioInputC2 connects to Channel12 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel12;
	/// GpioInputC2 connects to Channel12 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel12;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC2 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputC2 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioInputC2 as Channel12 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel12 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC2 as Channel12 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel12 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC2 as Channel12 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel12 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C2
/// @ingroup	stm32f407vg_gpio
struct GpioC2 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioC2 connects to Channel12 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel12;
	/// GpioC2 connects to Channel12 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel12;
	/// GpioC2 connects to Channel12 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel12;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC2 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioC2 as Miso to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioC2 as Channel12 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel12 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC2 as Channel12 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel12 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC2 as Channel12 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel12 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC2 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C3
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC3 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputC3 connects to Channel13 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel13;
	/// GpioOutputC3 connects to Channel13 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel13;
	/// GpioOutputC3 connects to Channel13 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel13;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC3 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioOutputC3 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C3
/// @ingroup	stm32f407vg_gpio
struct GpioInputC3 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputC3 connects to Channel13 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel13;
	/// GpioInputC3 connects to Channel13 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel13;
	/// GpioInputC3 connects to Channel13 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel13;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC3 as Channel13 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel13 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC3 as Channel13 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel13 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC3 as Channel13 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel13 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C3
/// @ingroup	stm32f407vg_gpio
struct GpioC3 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioC3 connects to Channel13 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel13;
	/// GpioC3 connects to Channel13 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel13;
	/// GpioC3 connects to Channel13 of Adc3
	static const ::xpcc::stm32::Adc3::Channel
	Adc3Channel = ::xpcc::stm32::Adc3::Channel::Channel13;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC3 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioC3 as Mosi to SpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_5);
	}
	/// Connect GpioC3 as Channel13 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel13 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC3 as Channel13 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel13 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC3 as Channel13 to Adc3.
	xpcc_always_inline static void
	connect(TypeId::Adc3Channel13 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC3 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C4
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC4 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputC4 connects to Channel14 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel14;
	/// GpioOutputC4 connects to Channel14 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel14;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C4
/// @ingroup	stm32f407vg_gpio
struct GpioInputC4 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputC4 connects to Channel14 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel14;
	/// GpioInputC4 connects to Channel14 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel14;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC4 as Channel14 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel14 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC4 as Channel14 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel14 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C4
/// @ingroup	stm32f407vg_gpio
struct GpioC4 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioC4 connects to Channel14 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel14;
	/// GpioC4 connects to Channel14 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel14;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC4 as Channel14 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel14 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC4 as Channel14 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel14 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC4 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C5
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC5 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioOutputC5 connects to Channel15 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel15;
	/// GpioOutputC5 connects to Channel15 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel15;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C5
/// @ingroup	stm32f407vg_gpio
struct GpioInputC5 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioInputC5 connects to Channel15 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel15;
	/// GpioInputC5 connects to Channel15 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel15;
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC5 as Channel15 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel15 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioInputC5 as Channel15 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel15 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C5
/// @ingroup	stm32f407vg_gpio
struct GpioC5 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	/// GpioC5 connects to Channel15 of Adc1
	static const ::xpcc::stm32::Adc1::Channel
	Adc1Channel = ::xpcc::stm32::Adc1::Channel::Channel15;
	/// GpioC5 connects to Channel15 of Adc2
	static const ::xpcc::stm32::Adc2::Channel
	Adc2Channel = ::xpcc::stm32::Adc2::Channel::Channel15;
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC5 as Channel15 to Adc1.
	xpcc_always_inline static void
	connect(TypeId::Adc1Channel15 /* t */) {
		setAnalogInput();
	}
	/// Connect GpioC5 as Channel15 to Adc2.
	xpcc_always_inline static void
	connect(TypeId::Adc2Channel15 /* t */) {
		setAnalogInput();
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC5 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C6
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC6 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputC6 as Tx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC6 as Tx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC6 as Mosi to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC6 as Mosi to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C6
/// @ingroup	stm32f407vg_gpio
struct GpioInputC6 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C6
/// @ingroup	stm32f407vg_gpio
struct GpioC6 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC6 as Channel1 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC6 as Channel1 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC6 as Tx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC6 as Tx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC6 as Mosi to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC6 as Mosi to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC6 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C7
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC7 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C7
/// @ingroup	stm32f407vg_gpio
struct GpioInputC7 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputC7 as Rx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputC7 as Rx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputC7 as Miso to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputC7 as Miso to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C7
/// @ingroup	stm32f407vg_gpio
struct GpioC7 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC7 as Channel2 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC7 as Channel2 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC7 as Rx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC7 as Rx to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC7 as Miso to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC7 as Miso to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC7 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C8
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC8 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputC8 as Ck to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC8 as Ck to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC8 as Sck to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC8 as Sck to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C8
/// @ingroup	stm32f407vg_gpio
struct GpioInputC8 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C8
/// @ingroup	stm32f407vg_gpio
struct GpioC8 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC8 as Channel3 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC8 as Channel3 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC8 as Ck to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC8 as Ck to Uart6.
	xpcc_always_inline static void
	connect(TypeId::Uart6Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC8 as Sck to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC8 as Sck to UartSpiMaster6.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster6Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC8 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C9
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC9 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC9 as  to ClockOutput2.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioOutputC9 as  to ClockOutput2.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioOutputC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C9
/// @ingroup	stm32f407vg_gpio
struct GpioInputC9 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C9
/// @ingroup	stm32f407vg_gpio
struct GpioC9 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC9 as  to ClockOutput2.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioC9 as  to ClockOutput2.
	xpcc_always_inline static void
	connect(TypeId::ClockOutput2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_0);
	}
	/// Connect GpioC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC9 as Channel4 to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC9 as Channel4 to Timer8.
	xpcc_always_inline static void
	connect(TypeId::Timer8Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioC9 as Sda to I2cMaster3.
	inline static void
	connect(TypeId::I2cMaster3Sda /* t */, InputType type=InputType::Floating) {
		configure(type);
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_4);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC9 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C10
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC10 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC10 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputC10 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputC10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC10 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC10 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C10
/// @ingroup	stm32f407vg_gpio
struct GpioInputC10 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C10
/// @ingroup	stm32f407vg_gpio
struct GpioC10 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC10 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioC10 as Sck to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioC10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC10 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC10 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC10 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC10 as Tx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC10 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C11
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC11 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C11
/// @ingroup	stm32f407vg_gpio
struct GpioInputC11 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputC11 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioInputC11 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioInputC11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputC11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputC11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputC11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputC11 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputC11 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C11
/// @ingroup	stm32f407vg_gpio
struct GpioC11 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC11 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioC11 as Miso to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioC11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC11 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC11 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC11 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC11 as Rx to Uart4.
	xpcc_always_inline static void
	connect(TypeId::Uart4Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC11 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C12
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC12 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputC12 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputC12 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioOutputC12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputC12 as Tx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioOutputC12 as Tx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C12
/// @ingroup	stm32f407vg_gpio
struct GpioInputC12 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C12
/// @ingroup	stm32f407vg_gpio
struct GpioC12 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioC12 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioC12 as Mosi to SpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::SpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_6);
	}
	/// Connect GpioC12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC12 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC12 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioC12 as Tx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioC12 as Tx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC12 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C13
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC13 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C13
/// @ingroup	stm32f407vg_gpio
struct GpioInputC13 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C13
/// @ingroup	stm32f407vg_gpio
struct GpioC13 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC13 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C14
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC14 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C14
/// @ingroup	stm32f407vg_gpio
struct GpioInputC14 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C14
/// @ingroup	stm32f407vg_gpio
struct GpioC14 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC14 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin C15
/// @ingroup	stm32f407vg_gpio
struct GpioOutputC15 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOC->MODER &= ~mask2;
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
		GPIOC->PUPDR &= ~mask2;
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin C15
/// @ingroup	stm32f407vg_gpio
struct GpioInputC15 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin C15
/// @ingroup	stm32f407vg_gpio
struct GpioC15 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::C;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOC->MODER = (GPIOC->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOC->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOC->OTYPER  = (GPIOC->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOC->OSPEEDR = (GPIOC->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOC->PUPDR   = (GPIOC->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER   = (GPIOC->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOC->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOC->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOC->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOC->MODER   &= ~mask2;
		// reset output type and speed
		GPIOC->OTYPER  &= ~mask;
		GPIOC->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOC->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOC->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOC->AFR[af_id] = (GPIOC->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioC15 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D0
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD0 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D0
/// @ingroup	stm32f407vg_gpio
struct GpioInputD0 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD0 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputD0 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioInputD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D0
/// @ingroup	stm32f407vg_gpio
struct GpioD0 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD0 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioD0 as Rx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD0 as D2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD0 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D1
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD1 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD1 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputD1 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioOutputD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D1
/// @ingroup	stm32f407vg_gpio
struct GpioInputD1 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D1
/// @ingroup	stm32f407vg_gpio
struct GpioD1 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD1 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioD1 as Tx to Can1.
	xpcc_always_inline static void
	connect(TypeId::Can1Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_9);
	}
	/// Connect GpioD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD1 as D3 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD1 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D2
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD2 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D2
/// @ingroup	stm32f407vg_gpio
struct GpioInputD2 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD2 as ExternalTrigger to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD2 as ExternalTrigger to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD2 as Rx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioInputD2 as Rx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D2
/// @ingroup	stm32f407vg_gpio
struct GpioD2 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD2 as ExternalTrigger to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD2 as ExternalTrigger to Timer3.
	xpcc_always_inline static void
	connect(TypeId::Timer3ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD2 as Rx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_8);
	}
	/// Connect GpioD2 as Rx to Uart5.
	xpcc_always_inline static void
	connect(TypeId::Uart5Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_8);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD2 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D3
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD3 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D3
/// @ingroup	stm32f407vg_gpio
struct GpioInputD3 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD3 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD3 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D3
/// @ingroup	stm32f407vg_gpio
struct GpioD3 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD3 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD3 as Cts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD3 as Clk to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcClk /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD3 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D4
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD4 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD4 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD4 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D4
/// @ingroup	stm32f407vg_gpio
struct GpioInputD4 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D4
/// @ingroup	stm32f407vg_gpio
struct GpioD4 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD4 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD4 as Rts to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD4 as Noe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNoe /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD4 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D5
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD5 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD5 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD5 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD5 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD5 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D5
/// @ingroup	stm32f407vg_gpio
struct GpioInputD5 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D5
/// @ingroup	stm32f407vg_gpio
struct GpioD5 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD5 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD5 as Tx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD5 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD5 as Mosi to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD5 as Nwe to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwe /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD5 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D6
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD6 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D6
/// @ingroup	stm32f407vg_gpio
struct GpioInputD6 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD6 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD6 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD6 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD6 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D6
/// @ingroup	stm32f407vg_gpio
struct GpioD6 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD6 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD6 as Rx to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD6 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD6 as Miso to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD6 as Nwait to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNwait /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD6 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D7
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD7 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD7 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD7 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD7 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD7 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D7
/// @ingroup	stm32f407vg_gpio
struct GpioInputD7 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D7
/// @ingroup	stm32f407vg_gpio
struct GpioD7 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD7 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD7 as Ck to Uart2.
	xpcc_always_inline static void
	connect(TypeId::Uart2Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD7 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD7 as Sck to UartSpiMaster2.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster2Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD7 as Nce2 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNce2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD7 as Ne1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNe1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD7 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D8
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD8 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD8 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD8 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD8 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD8 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D8
/// @ingroup	stm32f407vg_gpio
struct GpioInputD8 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D8
/// @ingroup	stm32f407vg_gpio
struct GpioD8 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD8 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD8 as Tx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Tx /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD8 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD8 as Mosi to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Mosi /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD8 as D13 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD13 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD8 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D9
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD9 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D9
/// @ingroup	stm32f407vg_gpio
struct GpioInputD9 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD9 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD9 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD9 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD9 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D9
/// @ingroup	stm32f407vg_gpio
struct GpioD9 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD9 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD9 as Rx to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rx /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD9 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD9 as Miso to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Miso /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD9 as D14 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD14 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD9 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D10
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD10 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD10 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD10 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD10 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD10 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D10
/// @ingroup	stm32f407vg_gpio
struct GpioInputD10 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D10
/// @ingroup	stm32f407vg_gpio
struct GpioD10 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD10 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD10 as Ck to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Ck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD10 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD10 as Sck to UartSpiMaster3.
	xpcc_always_inline static void
	connect(TypeId::UartSpiMaster3Sck /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD10 as D15 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD15 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD10 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D11
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD11 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D11
/// @ingroup	stm32f407vg_gpio
struct GpioInputD11 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD11 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD11 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioInputD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D11
/// @ingroup	stm32f407vg_gpio
struct GpioD11 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD11 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD11 as Cts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Cts /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD11 as A16 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA16 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD11 as Cle to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcCle /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD11 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D12
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD12 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD12 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD12 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioOutputD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D12
/// @ingroup	stm32f407vg_gpio
struct GpioInputD12 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D12
/// @ingroup	stm32f407vg_gpio
struct GpioD12 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD12 as Channel1 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD12 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */) {
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD12 as Rts to Uart3.
	xpcc_always_inline static void
	connect(TypeId::Uart3Rts /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_7);
	}
	/// Connect GpioD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD12 as A17 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA17 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD12 as Ale to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcAle /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD12 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D13
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD13 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D13
/// @ingroup	stm32f407vg_gpio
struct GpioInputD13 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D13
/// @ingroup	stm32f407vg_gpio
struct GpioD13 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD13 as Channel2 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD13 as A18 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA18 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD13 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D14
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD14 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D14
/// @ingroup	stm32f407vg_gpio
struct GpioInputD14 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D14
/// @ingroup	stm32f407vg_gpio
struct GpioD14 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD14 as Channel3 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD14 as D0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD0 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD14 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin D15
/// @ingroup	stm32f407vg_gpio
struct GpioOutputD15 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOD->MODER &= ~mask2;
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
		GPIOD->PUPDR &= ~mask2;
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioOutputD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin D15
/// @ingroup	stm32f407vg_gpio
struct GpioInputD15 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin D15
/// @ingroup	stm32f407vg_gpio
struct GpioD15 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::D;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOD->MODER = (GPIOD->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOD->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOD->OTYPER  = (GPIOD->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOD->OSPEEDR = (GPIOD->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOD->PUPDR   = (GPIOD->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER   = (GPIOD->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOD->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOD->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOD->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOD->MODER   &= ~mask2;
		// reset output type and speed
		GPIOD->OTYPER  &= ~mask;
		GPIOD->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOD->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOD->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOD->AFR[af_id] = (GPIOD->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD15 as Channel4 to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioD15 as D1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioD15 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E0
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE0 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E0
/// @ingroup	stm32f407vg_gpio
struct GpioInputE0 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE0 as ExternalTrigger to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputE0 as ExternalTrigger to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioInputE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E0
/// @ingroup	stm32f407vg_gpio
struct GpioE0 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE0 as ExternalTrigger to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioE0 as ExternalTrigger to Timer4.
	xpcc_always_inline static void
	connect(TypeId::Timer4ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_2);
	}
	/// Connect GpioE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE0 as Nbl0 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl0 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE0 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E1
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE1 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E1
/// @ingroup	stm32f407vg_gpio
struct GpioInputE1 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E1
/// @ingroup	stm32f407vg_gpio
struct GpioE1 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE1 as Nbl1 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcNbl1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE1 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E2
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE2 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E2
/// @ingroup	stm32f407vg_gpio
struct GpioInputE2 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E2
/// @ingroup	stm32f407vg_gpio
struct GpioE2 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 2;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE2 as A23 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA23 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE2 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E3
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE3 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E3
/// @ingroup	stm32f407vg_gpio
struct GpioInputE3 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E3
/// @ingroup	stm32f407vg_gpio
struct GpioE3 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 3;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI3_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE3 as A19 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA19 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE3 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E4
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE4 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E4
/// @ingroup	stm32f407vg_gpio
struct GpioInputE4 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E4
/// @ingroup	stm32f407vg_gpio
struct GpioE4 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 4;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE4 as A20 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA20 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE4 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E5
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE5 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E5
/// @ingroup	stm32f407vg_gpio
struct GpioInputE5 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E5
/// @ingroup	stm32f407vg_gpio
struct GpioE5 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 5;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioE5 as Channel1 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE5 as A21 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA21 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE5 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E6
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE6 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioOutputE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E6
/// @ingroup	stm32f407vg_gpio
struct GpioInputE6 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioInputE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E6
/// @ingroup	stm32f407vg_gpio
struct GpioE6 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 6;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioE6 as Channel2 to Timer9.
	xpcc_always_inline static void
	connect(TypeId::Timer9Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_3);
	}
	/// Connect GpioE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE6 as A22 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcA22 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE6 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E7
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE7 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E7
/// @ingroup	stm32f407vg_gpio
struct GpioInputE7 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE7 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE7 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E7
/// @ingroup	stm32f407vg_gpio
struct GpioE7 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 7;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE7 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE7 as ExternalTrigger to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1ExternalTrigger /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE7 as D4 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE7 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E8
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE8 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E8
/// @ingroup	stm32f407vg_gpio
struct GpioInputE8 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E8
/// @ingroup	stm32f407vg_gpio
struct GpioE8 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 8;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE8 as Channel1N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE8 as D5 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD5 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE8 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E9
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE9 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E9
/// @ingroup	stm32f407vg_gpio
struct GpioInputE9 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E9
/// @ingroup	stm32f407vg_gpio
struct GpioE9 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 9;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE9 as Channel1 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel1 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE9 as D6 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD6 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE9 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E10
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE10 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E10
/// @ingroup	stm32f407vg_gpio
struct GpioInputE10 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E10
/// @ingroup	stm32f407vg_gpio
struct GpioE10 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 10;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE10 as Channel2N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE10 as D7 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD7 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE10 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E11
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE11 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E11
/// @ingroup	stm32f407vg_gpio
struct GpioInputE11 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E11
/// @ingroup	stm32f407vg_gpio
struct GpioE11 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 11;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE11 as Channel2 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel2 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE11 as D8 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD8 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE11 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E12
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE12 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E12
/// @ingroup	stm32f407vg_gpio
struct GpioInputE12 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E12
/// @ingroup	stm32f407vg_gpio
struct GpioE12 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 12;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE12 as Channel3N to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3N /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE12 as D9 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD9 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE12 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E13
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE13 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E13
/// @ingroup	stm32f407vg_gpio
struct GpioInputE13 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E13
/// @ingroup	stm32f407vg_gpio
struct GpioE13 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 13;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE13 as Channel3 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel3 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE13 as D10 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD10 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE13 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E14
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE14 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioOutputE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E14
/// @ingroup	stm32f407vg_gpio
struct GpioInputE14 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E14
/// @ingroup	stm32f407vg_gpio
struct GpioE14 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 14;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE14 as Channel4 to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1Channel4 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE14 as D11 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD11 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE14 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin E15
/// @ingroup	stm32f407vg_gpio
struct GpioOutputE15 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOE->MODER &= ~mask2;
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
		GPIOE->PUPDR &= ~mask2;
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioOutputE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioOutputE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin E15
/// @ingroup	stm32f407vg_gpio
struct GpioInputE15 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioInputE15 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE15 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioInputE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioInputE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin E15
/// @ingroup	stm32f407vg_gpio
struct GpioE15 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::E;
	/// Pin Number.
	static constexpr uint8_t pin = 15;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOE->MODER = (GPIOE->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOE->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOE->OTYPER  = (GPIOE->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOE->OSPEEDR = (GPIOE->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOE->PUPDR   = (GPIOE->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER   = (GPIOE->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOE->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOE->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOE->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOE->MODER   &= ~mask2;
		// reset output type and speed
		GPIOE->OTYPER  &= ~mask;
		GPIOE->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOE->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOE->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOE->AFR[af_id] = (GPIOE->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	/// Connect GpioE15 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */) {
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE15 as BreakIn to Timer1.
	xpcc_always_inline static void
	connect(TypeId::Timer1BreakIn /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_1);
	}
	/// Connect GpioE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */) {
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	/// Connect GpioE15 as D12 to Fsmc.
	xpcc_always_inline static void
	connect(TypeId::FsmcD12 /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_12);
	}
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioE15 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin H0
/// @ingroup	stm32f407vg_gpio
struct GpioOutputH0 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::H;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOH->MODER = (GPIOH->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOH->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOH->OTYPER  = (GPIOH->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOH->OSPEEDR = (GPIOH->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOH->PUPDR   = (GPIOH->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOH->MODER   = (GPIOH->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOH->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOH->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOH->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOH->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOH->MODER &= ~mask2;
		GPIOH->OTYPER  &= ~mask;
		GPIOH->OSPEEDR &= ~mask2;
		GPIOH->PUPDR &= ~mask2;
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin H0
/// @ingroup	stm32f407vg_gpio
struct GpioInputH0 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::H;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOH->MODER = (GPIOH->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOH->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOH->OTYPER  = (GPIOH->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOH->OSPEEDR = (GPIOH->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOH->PUPDR   = (GPIOH->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOH->MODER   &= ~mask2;
		// reset output type and speed
		GPIOH->OTYPER  &= ~mask;
		GPIOH->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOH->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOH->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin H0
/// @ingroup	stm32f407vg_gpio
struct GpioH0 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::H;
	/// Pin Number.
	static constexpr uint8_t pin = 0;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOH->MODER = (GPIOH->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOH->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOH->OTYPER  = (GPIOH->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOH->OSPEEDR = (GPIOH->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOH->PUPDR   = (GPIOH->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOH->MODER   = (GPIOH->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOH->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOH->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOH->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOH->MODER   &= ~mask2;
		// reset output type and speed
		GPIOH->OTYPER  &= ~mask;
		GPIOH->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOH->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOH->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioH0 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// Output class for Pin H1
/// @ingroup	stm32f407vg_gpio
struct GpioOutputH1 : public Gpio, ::xpcc::GpioOutput
{
public:
	/// Port name.
	static constexpr Port port = Port::H;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOH->MODER = (GPIOH->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOH->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOH->OTYPER  = (GPIOH->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOH->OSPEEDR = (GPIOH->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOH->PUPDR   = (GPIOH->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOH->MODER   = (GPIOH->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOH->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOH->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOH->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOH->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		GPIOH->MODER &= ~mask2;
		GPIOH->OTYPER  &= ~mask;
		GPIOH->OSPEEDR &= ~mask2;
		GPIOH->PUPDR &= ~mask2;
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
};

/// Input class for Pin H1
/// @ingroup	stm32f407vg_gpio
struct GpioInputH1 : public Gpio, ::xpcc::GpioInput
{
public:
	/// Port name.
	static constexpr Port port = Port::H;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOH->MODER = (GPIOH->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOH->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOH->OTYPER  = (GPIOH->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOH->OSPEEDR = (GPIOH->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOH->PUPDR   = (GPIOH->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOH->MODER   &= ~mask2;
		// reset output type and speed
		GPIOH->OTYPER  &= ~mask;
		GPIOH->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOH->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOH->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};

/// IO class for Pin H1
/// @ingroup	stm32f407vg_gpio
struct GpioH1 : public Gpio, ::xpcc::GpioIO
{
public:
	/// Port name.
	static constexpr Port port = Port::H;
	/// Pin Number.
	static constexpr uint8_t pin = 1;
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI1_IRQn;
	xpcc_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		GPIOH->MODER = (GPIOH->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	xpcc_always_inline static void
	setAnalogInput() {
		GPIOH->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	xpcc_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIOH->OTYPER  = (GPIOH->OTYPER  & ~mask)  | (i(type) << pin);
		GPIOH->OSPEEDR = (GPIOH->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	xpcc_always_inline static void configure(InputType type) {
		GPIOH->PUPDR   = (GPIOH->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	// GpioOutput
	// start documentation inherited
	xpcc_always_inline static void setOutput() {
		GPIOH->MODER   = (GPIOH->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	xpcc_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	xpcc_always_inline static void set() {
		GPIOH->BSRR = mask;
	}
	xpcc_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	xpcc_always_inline static void reset() {
		GPIOH->BSRR = (uint32_t(mask) << 16);
	}
	xpcc_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	xpcc_always_inline static bool isSet() {
		return (GPIOH->ODR & mask);
	}
	// stop documentation inherited
	xpcc_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		GPIOH->MODER   &= ~mask2;
		// reset output type and speed
		GPIOH->OTYPER  &= ~mask;
		GPIOH->OSPEEDR &= ~mask2;
	}
	xpcc_always_inline static bool read() {
		return (GPIOH->IDR & mask);
	}
	// end documentation inherited
	xpcc_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	xpcc_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	xpcc_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	xpcc_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	xpcc_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	xpcc_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	xpcc_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = (GPIOH->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	xpcc_always_inline static void
	disconnect() {
		setInput(InputType::Floating);
		GPIOH->AFR[af_id] = (GPIOH->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	// connect: Software Gpio
	/// Connect to `SoftwareSpiMasterMosi`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMosi) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareSpiMasterSck`.
	inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterSck) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
	/// Connect to `SoftwareI2cMasterSda`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda, InputType type=InputType::Floating) {
		configure(type);
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareI2cMasterScl`.
	inline static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl, InputType type=InputType::Floating) {
		configure(type);
		I2c::resetDevices< GpioH1 >();
		set();
		setOutput(OutputType::OpenDrain);
	}
	/// Connect to `SoftwareSpiMasterMiso`.
	xpcc_always_inline static void
	connect(::xpcc::TypeId::SoftwareSpiMasterMiso) {
		configure(InputType::Floating);
		setInput();
	}
};


/// @cond
template< Gpio::Port Port, uint8_t StartPin, uint8_t Width, GpioPort::DataOrder PortOrder>
class GpioPortBase;
/// @endcond

/**
 * Creates a hardware port with StartPin as LSB and with Width.
 *
 * @tparam	StartPin	a Gpio pin
 * @tparam	Width		required width of the port (up to 16)
 * @ingroup stm32f407vg_gpio
 */
template< typename StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder = GpioPort::DataOrder::Normal >
class GpioPort : public ::xpcc::GpioPort, /** @cond */ public GpioPortBase< StartPin::port, StartPin::pin, Width, PortOrder > /** @endcond */
{
public:
	static constexpr uint8_t width = Width;

	static constexpr DataOrder
	getDataOrder()
	{ return PortOrder; }

	using PortType = uint16_t;

#ifdef __DOXYGEN__
	static void
	setOutput();

	static void
	setInput();

	static PortType
	read();

	static void
	write(PortType data);

	static void
	toggle();
#endif
};

/// @cond
// there is no extra optimized specialization for Width=16 or DataOrder::Reversed, since using
// a 16bit port is relatively rare and the optimizer will optimize the heck out of it anyway.
template< uint8_t StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::A, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < 16,
			"Port StartPin too large, maximum 16.");
	static_assert(Width <= 16,
			"Port Width too large, maximum 16.");
	static_assert(Width > 0,
			"Port Width should be at least 1.");
	static_assert(StartPin + Width <= 16,
			"Port StartPin + Width too large, maximum 16.");

	static constexpr uint8_t StartPinReversed = (8 - StartPin - Width) + 8;
	static constexpr uint16_t dataMask = (1 << Width) - 1;
	static constexpr uint16_t portMask = dataMask << StartPin;
	static constexpr uint32_t portMask2 = portMask | (portMask << Width);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	xpcc_always_inline static void setOutput() {
		GPIOA->MODER = (GPIOA->MODER & ~portMask2) | port01;
	}
	xpcc_always_inline static void setInput() {
		GPIOA->MODER &= ~portMask2;
	}
	inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50)
	{
		if (type == OutputType::OpenDrain) {
			GPIOA->OTYPER |= portMask;
		} else {
			GPIOA->OTYPER &= ~portMask;
		}
		GPIOA->OSPEEDR &= ~portMask2;
		if (i(speed) == 0b01) {
			GPIOA->OSPEEDR |= port01;
		} else if (i(speed) == 0b10) {
			GPIOA->OSPEEDR |= port10;
		} else if (i(speed) == 0b11) {
			GPIOA->OSPEEDR |= portMask2;
		}
	}
	inline static void configure(InputType type)
	{
		GPIOA->PUPDR &= ~portMask2;
		if (i(type) == 0b01) {
			GPIOA->PUPDR |= port01;
		} else if (i(type) == 0b10) {
			GPIOA->PUPDR |= port10;
		}
	}
	inline static uint16_t read() {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			uint16_t data = GPIOA->IDR & portMask;
			return (data >> StartPin);
		} else {
			uint16_t data = xpcc::bitReverse(uint16_t(GPIOA->IDR & portMask));
			return (data >> StartPinReversed);
		}
	}
	inline static void write(uint16_t data) {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			data <<= StartPin;
			GPIOA->ODR = (GPIOA->ODR & ~portMask) | (data & portMask);
		} else {
			data = xpcc::bitReverse(uint16_t(data << StartPinReversed));
			GPIOA->ODR = (GPIOA->ODR & ~portMask) | (data & portMask);
		}
	}
};

template< uint8_t StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::C, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < 16,
			"Port StartPin too large, maximum 16.");
	static_assert(Width <= 16,
			"Port Width too large, maximum 16.");
	static_assert(Width > 0,
			"Port Width should be at least 1.");
	static_assert(StartPin + Width <= 16,
			"Port StartPin + Width too large, maximum 16.");

	static constexpr uint8_t StartPinReversed = (8 - StartPin - Width) + 8;
	static constexpr uint16_t dataMask = (1 << Width) - 1;
	static constexpr uint16_t portMask = dataMask << StartPin;
	static constexpr uint32_t portMask2 = portMask | (portMask << Width);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	xpcc_always_inline static void setOutput() {
		GPIOC->MODER = (GPIOC->MODER & ~portMask2) | port01;
	}
	xpcc_always_inline static void setInput() {
		GPIOC->MODER &= ~portMask2;
	}
	inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50)
	{
		if (type == OutputType::OpenDrain) {
			GPIOC->OTYPER |= portMask;
		} else {
			GPIOC->OTYPER &= ~portMask;
		}
		GPIOC->OSPEEDR &= ~portMask2;
		if (i(speed) == 0b01) {
			GPIOC->OSPEEDR |= port01;
		} else if (i(speed) == 0b10) {
			GPIOC->OSPEEDR |= port10;
		} else if (i(speed) == 0b11) {
			GPIOC->OSPEEDR |= portMask2;
		}
	}
	inline static void configure(InputType type)
	{
		GPIOC->PUPDR &= ~portMask2;
		if (i(type) == 0b01) {
			GPIOC->PUPDR |= port01;
		} else if (i(type) == 0b10) {
			GPIOC->PUPDR |= port10;
		}
	}
	inline static uint16_t read() {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			uint16_t data = GPIOC->IDR & portMask;
			return (data >> StartPin);
		} else {
			uint16_t data = xpcc::bitReverse(uint16_t(GPIOC->IDR & portMask));
			return (data >> StartPinReversed);
		}
	}
	inline static void write(uint16_t data) {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			data <<= StartPin;
			GPIOC->ODR = (GPIOC->ODR & ~portMask) | (data & portMask);
		} else {
			data = xpcc::bitReverse(uint16_t(data << StartPinReversed));
			GPIOC->ODR = (GPIOC->ODR & ~portMask) | (data & portMask);
		}
	}
};

template< uint8_t StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::B, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < 16,
			"Port StartPin too large, maximum 16.");
	static_assert(Width <= 16,
			"Port Width too large, maximum 16.");
	static_assert(Width > 0,
			"Port Width should be at least 1.");
	static_assert(StartPin + Width <= 16,
			"Port StartPin + Width too large, maximum 16.");

	static constexpr uint8_t StartPinReversed = (8 - StartPin - Width) + 8;
	static constexpr uint16_t dataMask = (1 << Width) - 1;
	static constexpr uint16_t portMask = dataMask << StartPin;
	static constexpr uint32_t portMask2 = portMask | (portMask << Width);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	xpcc_always_inline static void setOutput() {
		GPIOB->MODER = (GPIOB->MODER & ~portMask2) | port01;
	}
	xpcc_always_inline static void setInput() {
		GPIOB->MODER &= ~portMask2;
	}
	inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50)
	{
		if (type == OutputType::OpenDrain) {
			GPIOB->OTYPER |= portMask;
		} else {
			GPIOB->OTYPER &= ~portMask;
		}
		GPIOB->OSPEEDR &= ~portMask2;
		if (i(speed) == 0b01) {
			GPIOB->OSPEEDR |= port01;
		} else if (i(speed) == 0b10) {
			GPIOB->OSPEEDR |= port10;
		} else if (i(speed) == 0b11) {
			GPIOB->OSPEEDR |= portMask2;
		}
	}
	inline static void configure(InputType type)
	{
		GPIOB->PUPDR &= ~portMask2;
		if (i(type) == 0b01) {
			GPIOB->PUPDR |= port01;
		} else if (i(type) == 0b10) {
			GPIOB->PUPDR |= port10;
		}
	}
	inline static uint16_t read() {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			uint16_t data = GPIOB->IDR & portMask;
			return (data >> StartPin);
		} else {
			uint16_t data = xpcc::bitReverse(uint16_t(GPIOB->IDR & portMask));
			return (data >> StartPinReversed);
		}
	}
	inline static void write(uint16_t data) {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			data <<= StartPin;
			GPIOB->ODR = (GPIOB->ODR & ~portMask) | (data & portMask);
		} else {
			data = xpcc::bitReverse(uint16_t(data << StartPinReversed));
			GPIOB->ODR = (GPIOB->ODR & ~portMask) | (data & portMask);
		}
	}
};

template< uint8_t StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::E, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < 16,
			"Port StartPin too large, maximum 16.");
	static_assert(Width <= 16,
			"Port Width too large, maximum 16.");
	static_assert(Width > 0,
			"Port Width should be at least 1.");
	static_assert(StartPin + Width <= 16,
			"Port StartPin + Width too large, maximum 16.");

	static constexpr uint8_t StartPinReversed = (8 - StartPin - Width) + 8;
	static constexpr uint16_t dataMask = (1 << Width) - 1;
	static constexpr uint16_t portMask = dataMask << StartPin;
	static constexpr uint32_t portMask2 = portMask | (portMask << Width);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	xpcc_always_inline static void setOutput() {
		GPIOE->MODER = (GPIOE->MODER & ~portMask2) | port01;
	}
	xpcc_always_inline static void setInput() {
		GPIOE->MODER &= ~portMask2;
	}
	inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50)
	{
		if (type == OutputType::OpenDrain) {
			GPIOE->OTYPER |= portMask;
		} else {
			GPIOE->OTYPER &= ~portMask;
		}
		GPIOE->OSPEEDR &= ~portMask2;
		if (i(speed) == 0b01) {
			GPIOE->OSPEEDR |= port01;
		} else if (i(speed) == 0b10) {
			GPIOE->OSPEEDR |= port10;
		} else if (i(speed) == 0b11) {
			GPIOE->OSPEEDR |= portMask2;
		}
	}
	inline static void configure(InputType type)
	{
		GPIOE->PUPDR &= ~portMask2;
		if (i(type) == 0b01) {
			GPIOE->PUPDR |= port01;
		} else if (i(type) == 0b10) {
			GPIOE->PUPDR |= port10;
		}
	}
	inline static uint16_t read() {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			uint16_t data = GPIOE->IDR & portMask;
			return (data >> StartPin);
		} else {
			uint16_t data = xpcc::bitReverse(uint16_t(GPIOE->IDR & portMask));
			return (data >> StartPinReversed);
		}
	}
	inline static void write(uint16_t data) {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			data <<= StartPin;
			GPIOE->ODR = (GPIOE->ODR & ~portMask) | (data & portMask);
		} else {
			data = xpcc::bitReverse(uint16_t(data << StartPinReversed));
			GPIOE->ODR = (GPIOE->ODR & ~portMask) | (data & portMask);
		}
	}
};

template< uint8_t StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::D, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < 16,
			"Port StartPin too large, maximum 16.");
	static_assert(Width <= 16,
			"Port Width too large, maximum 16.");
	static_assert(Width > 0,
			"Port Width should be at least 1.");
	static_assert(StartPin + Width <= 16,
			"Port StartPin + Width too large, maximum 16.");

	static constexpr uint8_t StartPinReversed = (8 - StartPin - Width) + 8;
	static constexpr uint16_t dataMask = (1 << Width) - 1;
	static constexpr uint16_t portMask = dataMask << StartPin;
	static constexpr uint32_t portMask2 = portMask | (portMask << Width);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	xpcc_always_inline static void setOutput() {
		GPIOD->MODER = (GPIOD->MODER & ~portMask2) | port01;
	}
	xpcc_always_inline static void setInput() {
		GPIOD->MODER &= ~portMask2;
	}
	inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50)
	{
		if (type == OutputType::OpenDrain) {
			GPIOD->OTYPER |= portMask;
		} else {
			GPIOD->OTYPER &= ~portMask;
		}
		GPIOD->OSPEEDR &= ~portMask2;
		if (i(speed) == 0b01) {
			GPIOD->OSPEEDR |= port01;
		} else if (i(speed) == 0b10) {
			GPIOD->OSPEEDR |= port10;
		} else if (i(speed) == 0b11) {
			GPIOD->OSPEEDR |= portMask2;
		}
	}
	inline static void configure(InputType type)
	{
		GPIOD->PUPDR &= ~portMask2;
		if (i(type) == 0b01) {
			GPIOD->PUPDR |= port01;
		} else if (i(type) == 0b10) {
			GPIOD->PUPDR |= port10;
		}
	}
	inline static uint16_t read() {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			uint16_t data = GPIOD->IDR & portMask;
			return (data >> StartPin);
		} else {
			uint16_t data = xpcc::bitReverse(uint16_t(GPIOD->IDR & portMask));
			return (data >> StartPinReversed);
		}
	}
	inline static void write(uint16_t data) {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			data <<= StartPin;
			GPIOD->ODR = (GPIOD->ODR & ~portMask) | (data & portMask);
		} else {
			data = xpcc::bitReverse(uint16_t(data << StartPinReversed));
			GPIOD->ODR = (GPIOD->ODR & ~portMask) | (data & portMask);
		}
	}
};

template< uint8_t StartPin, uint8_t Width, ::xpcc::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::H, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < 2,
			"Port StartPin too large, maximum 2.");
	static_assert(Width <= 2,
			"Port Width too large, maximum 2.");
	static_assert(Width > 0,
			"Port Width should be at least 1.");
	static_assert(StartPin + Width <= 2,
			"Port StartPin + Width too large, maximum 2.");

	static constexpr uint8_t StartPinReversed = (8 - StartPin - Width) + 8;
	static constexpr uint16_t dataMask = (1 << Width) - 1;
	static constexpr uint16_t portMask = dataMask << StartPin;
	static constexpr uint32_t portMask2 = portMask | (portMask << Width);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	xpcc_always_inline static void setOutput() {
		GPIOH->MODER = (GPIOH->MODER & ~portMask2) | port01;
	}
	xpcc_always_inline static void setInput() {
		GPIOH->MODER &= ~portMask2;
	}
	inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50)
	{
		if (type == OutputType::OpenDrain) {
			GPIOH->OTYPER |= portMask;
		} else {
			GPIOH->OTYPER &= ~portMask;
		}
		GPIOH->OSPEEDR &= ~portMask2;
		if (i(speed) == 0b01) {
			GPIOH->OSPEEDR |= port01;
		} else if (i(speed) == 0b10) {
			GPIOH->OSPEEDR |= port10;
		} else if (i(speed) == 0b11) {
			GPIOH->OSPEEDR |= portMask2;
		}
	}
	inline static void configure(InputType type)
	{
		GPIOH->PUPDR &= ~portMask2;
		if (i(type) == 0b01) {
			GPIOH->PUPDR |= port01;
		} else if (i(type) == 0b10) {
			GPIOH->PUPDR |= port10;
		}
	}
	inline static uint16_t read() {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			uint16_t data = GPIOH->IDR & portMask;
			return (data >> StartPin);
		} else {
			uint16_t data = xpcc::bitReverse(uint16_t(GPIOH->IDR & portMask));
			return (data >> StartPinReversed);
		}
	}
	inline static void write(uint16_t data) {
		if (PortOrder == ::xpcc::GpioPort::DataOrder::Normal) {   // this branch is optimized away
			data <<= StartPin;
			GPIOH->ODR = (GPIOH->ODR & ~portMask) | (data & portMask);
		} else {
			data = xpcc::bitReverse(uint16_t(data << StartPinReversed));
			GPIOH->ODR = (GPIOH->ODR & ~portMask) | (data & portMask);
		}
	}
};

/// @endcond

} // namespace stm32

} // namespace xpcc

#endif // XPCC_STM32_GPIO_HPP